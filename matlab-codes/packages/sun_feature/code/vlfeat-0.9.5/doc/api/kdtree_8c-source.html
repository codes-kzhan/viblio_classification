<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">   
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - Documentation - C API</title>
   
  
  <!-- Scripts-->
  
 </meta>
 
 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action="http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1>VLFeat.org</h1>
  </div>
  <div id="headbanner">
   Documentation - C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
    <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="../doc.html">Documentation</a>
<ul>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
    
    <div class="doxygen">
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>kdtree.c</h1><a href="kdtree_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00006"></a>00006 <span class="comment">/* AUTORIGHTS</span>
<a name="l00007"></a>00007 <span class="comment"> Copyright (C) 2007-09 Andrea Vedaldi and Brian Fulkerson</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment"> This file is part of VLFeat, available in the terms of the GNU</span>
<a name="l00010"></a>00010 <span class="comment"> General Public License version 2.</span>
<a name="l00011"></a>00011 <span class="comment"> */</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="kdtree_8h.html" title="KD-tree.">kdtree.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="generic_8h.html" title="Generic.">generic.h</a>"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include "<a class="code" href="random_8h.html" title="Random number generator.">random.h</a>"</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include "<a class="code" href="mathop_8h.html" title="Math operations.">mathop.h</a>"</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00019"></a>00019 
<a name="l00087"></a>00087 <span class="preprocessor">#define NAME vl_kdforest_search_heap</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="preprocessor">#define T VlKDForestSearchState</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#define CMP(x,y) (x-&gt;distanceLowerBound - y-&gt;distanceLowerBound)</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="heap-t_8h.html" title="Heap template.">heap-t.h</a>"</span>
<a name="l00091"></a>00091 <span class="preprocessor">#undef CMP</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#undef T</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span><span class="preprocessor">#undef NAME</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="preprocessor">#define NAME vl_kdtree_split_heap</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="preprocessor">#define T VlKDTreeSplitDimension</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#define CMP(x,y) (x-&gt;variance - y-&gt;variance)</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="heap-t_8h.html" title="Heap template.">heap-t.h</a>"</span>
<a name="l00099"></a>00099 <span class="preprocessor">#undef CMP</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span><span class="preprocessor">#undef T</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span><span class="preprocessor">#undef NAME</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="preprocessor">#define NAME vl_kdforest_neighbor_heap</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define T VlKDForestNeighbor</span>
<a name="l00105"></a>00105 <span class="preprocessor"></span><span class="preprocessor">#define CMP(x,y) (y-&gt;distance - x-&gt;distance)</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="heap-t_8h.html" title="Heap template.">heap-t.h</a>"</span>
<a name="l00107"></a>00107 <span class="preprocessor">#undef CMP</span>
<a name="l00108"></a>00108 <span class="preprocessor"></span><span class="preprocessor">#undef T</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span><span class="preprocessor">#undef NAME</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00117"></a>00117 <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span>
<a name="l00118"></a><a class="code" href="kdtree_8c.html#0f8bcfc1860957b70cdbcbf6e03e0425">00118</a> <a class="code" href="kdtree_8c.html#0f8bcfc1860957b70cdbcbf6e03e0425" title="Allocate a new node from the tree pool.">vl_kdtree_node_new</a> (VlKDTree * tree, <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> parentIndex)
<a name="l00119"></a>00119 {
<a name="l00120"></a>00120   VlKDTreeNode * node = NULL ;
<a name="l00121"></a>00121   <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> nodeIndex = tree-&gt;numUsedNodes ;
<a name="l00122"></a>00122   tree -&gt; numUsedNodes += 1 ;
<a name="l00123"></a>00123 
<a name="l00124"></a>00124   assert (tree-&gt;numUsedNodes &lt;= tree-&gt;numAllocatedNodes) ;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   node = tree-&gt;nodes + nodeIndex ;
<a name="l00127"></a>00127   node -&gt; parent = parentIndex ;
<a name="l00128"></a>00128   node -&gt; lowerChild = 0 ;
<a name="l00129"></a>00129   node -&gt; upperChild = 0 ;
<a name="l00130"></a>00130   node -&gt; splitDimension = 0 ;
<a name="l00131"></a>00131   node -&gt; splitThreshold = 0 ;
<a name="l00132"></a>00132   <span class="keywordflow">return</span> nodeIndex ;
<a name="l00133"></a>00133 }
<a name="l00134"></a>00134 
<a name="l00140"></a>00140 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00141"></a><a class="code" href="kdtree_8c.html#9de65262a119712c22e68fbfca3d02ac">00141</a> <a class="code" href="kdtree_8c.html#9de65262a119712c22e68fbfca3d02ac" title="Compare KDTree index entries for sorting.">vl_kdtree_compare_index_entries</a> (<span class="keywordtype">void</span> <span class="keyword">const</span> * a,
<a name="l00142"></a>00142                                  <span class="keywordtype">void</span> <span class="keyword">const</span> * b)
<a name="l00143"></a>00143 {
<a name="l00144"></a>00144   <span class="keywordtype">float</span> delta =
<a name="l00145"></a>00145    ((VlKDTreeDataIndexEntry <span class="keyword">const</span>*)a) -&gt; value -
<a name="l00146"></a>00146    ((VlKDTreeDataIndexEntry <span class="keyword">const</span>*)b) -&gt; value ;
<a name="l00147"></a>00147   <span class="keywordflow">if</span> (delta &lt; 0) <span class="keywordflow">return</span> -1 ;
<a name="l00148"></a>00148   <span class="keywordflow">if</span> (delta &gt; 0) <span class="keywordflow">return</span> +1 ;
<a name="l00149"></a>00149   <span class="keywordflow">return</span> 0 ;
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00162"></a>00162 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00163"></a>00163 <a class="code" href="kdtree_8c.html#e7b96fbb8190854a8fef25e7e4d82bc0" title="Build KDTree recursively.">vl_kdtree_build_recursively</a>
<a name="l00164"></a><a class="code" href="kdtree_8c.html#e7b96fbb8190854a8fef25e7e4d82bc0">00164</a> (<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> * forest,
<a name="l00165"></a>00165  VlKDTree * tree, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeIndex,
<a name="l00166"></a>00166  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataBegin, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dataEnd,
<a name="l00167"></a>00167  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depth)
<a name="l00168"></a>00168 {
<a name="l00169"></a>00169   <span class="keywordtype">int</span> d, i, medianIndex, splitIndex ;
<a name="l00170"></a>00170   VlKDTreeNode * node = tree-&gt;nodes + nodeIndex ;
<a name="l00171"></a>00171   VlKDTreeSplitDimension * splitDimension ;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="comment">/* base case: there is only one data point */</span>
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (dataEnd - dataBegin &lt;= 1) {
<a name="l00175"></a>00175     <span class="keywordflow">if</span> (tree-&gt;depth &lt; depth) tree-&gt;depth = depth ;
<a name="l00176"></a>00176     node-&gt;lowerChild = - dataBegin - 1;
<a name="l00177"></a>00177     node-&gt;upperChild = - dataEnd - 1 ;
<a name="l00178"></a>00178     return ;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   <span class="comment">/* compute the dimension with largest variance */</span>
<a name="l00182"></a>00182   forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a> = 0 ;
<a name="l00183"></a>00183   <span class="keywordflow">for</span> (d = 0 ; d &lt; forest-&gt;<a class="code" href="struct__VlKDForest.html#db5257b5aaa1b5a3b28f75ce86604067">numDimensions</a> ; ++ d) {
<a name="l00184"></a>00184     <span class="keywordtype">float</span> mean = 0 ; <span class="comment">/* unnormalized */</span>
<a name="l00185"></a>00185     <span class="keywordtype">float</span> secondMoment = 0 ;
<a name="l00186"></a>00186     <span class="keywordtype">float</span> variance = 0 ;
<a name="l00187"></a>00187     <span class="keywordflow">for</span> (i = dataBegin ; i &lt; dataEnd ; ++ i) {
<a name="l00188"></a>00188       <span class="keywordtype">int</span> di = tree -&gt; dataIndex [i] .index ;
<a name="l00189"></a>00189       <span class="keywordtype">float</span> <span class="keyword">const</span> datum = forest-&gt;<a class="code" href="struct__VlKDForest.html#d30a7279096b730eeb88c39da3008c22">data</a> [di * forest-&gt;<a class="code" href="struct__VlKDForest.html#db5257b5aaa1b5a3b28f75ce86604067">numDimensions</a> + d] ;
<a name="l00190"></a>00190       mean += datum ;
<a name="l00191"></a>00191       secondMoment += datum * datum ;
<a name="l00192"></a>00192     }
<a name="l00193"></a>00193     mean /= (dataEnd - dataBegin) ;
<a name="l00194"></a>00194     secondMoment /= (dataEnd - dataBegin) ;
<a name="l00195"></a>00195     variance = secondMoment - mean * mean ;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197     <span class="comment">/* keep splitHeapSize most varying dimensions */</span>
<a name="l00198"></a>00198     <span class="keywordflow">if</span> (forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a> &lt; forest-&gt;<a class="code" href="struct__VlKDForest.html#5616e99bc33e6d8d5210614a86d01faf">splitHeapSize</a>) {
<a name="l00199"></a>00199       VlKDTreeSplitDimension * splitDimension
<a name="l00200"></a>00200         = forest-&gt;<a class="code" href="struct__VlKDForest.html#33595082d277d41e2b678be69d39952d">splitHeapArray</a> + forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a> ;
<a name="l00201"></a>00201       splitDimension-&gt;dimension = d ;
<a name="l00202"></a>00202       splitDimension-&gt;mean = mean ;
<a name="l00203"></a>00203       splitDimension-&gt;variance = variance ;
<a name="l00204"></a>00204       vl_kdtree_split_heap_push (forest-&gt;<a class="code" href="struct__VlKDForest.html#33595082d277d41e2b678be69d39952d">splitHeapArray</a>, &amp;forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a>) ;
<a name="l00205"></a>00205     } <span class="keywordflow">else</span> {
<a name="l00206"></a>00206       VlKDTreeSplitDimension * splitDimension = forest-&gt;<a class="code" href="struct__VlKDForest.html#33595082d277d41e2b678be69d39952d">splitHeapArray</a> + 0 ;
<a name="l00207"></a>00207       <span class="keywordflow">if</span> (splitDimension-&gt;variance &lt; variance) {
<a name="l00208"></a>00208         splitDimension-&gt;dimension = d ;
<a name="l00209"></a>00209         splitDimension-&gt;mean = mean ;
<a name="l00210"></a>00210         splitDimension-&gt;variance = variance ;
<a name="l00211"></a>00211         vl_kdtree_split_heap_update (forest-&gt;<a class="code" href="struct__VlKDForest.html#33595082d277d41e2b678be69d39952d">splitHeapArray</a>, forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a>, 0) ;
<a name="l00212"></a>00212       }
<a name="l00213"></a>00213     }
<a name="l00214"></a>00214   }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="comment">/* toss a dice to decide the splitting dimension */</span>
<a name="l00217"></a>00217   splitDimension = forest-&gt;<a class="code" href="struct__VlKDForest.html#33595082d277d41e2b678be69d39952d">splitHeapArray</a>
<a name="l00218"></a>00218   + (<a class="code" href="random_8c.html#d86f024c0b55aa91ad808e9770b00f4e" title="Generate a random UINT32.">vl_rand_uint32</a>() % <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(forest-&gt;<a class="code" href="struct__VlKDForest.html#5616e99bc33e6d8d5210614a86d01faf">splitHeapSize</a>, forest-&gt;<a class="code" href="struct__VlKDForest.html#12f3e1316db5302aec4b7c90394b7344">splitHeapNumNodes</a>)) ;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="comment">/* additional base case: variance is equal to 0 (overlapping points) */</span>
<a name="l00221"></a>00221   <span class="keywordflow">if</span> (splitDimension-&gt;variance == 0) {
<a name="l00222"></a>00222     node-&gt;lowerChild = - dataBegin - 1 ;
<a name="l00223"></a>00223     node-&gt;upperChild = - dataEnd - 1 ;
<a name="l00224"></a>00224     return ;
<a name="l00225"></a>00225   }
<a name="l00226"></a>00226   node-&gt;splitDimension = splitDimension-&gt;dimension ;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="comment">/* sort data along largest variance dimension */</span>
<a name="l00229"></a>00229   <span class="keywordflow">for</span> (i = dataBegin ; i &lt; dataEnd ; ++ i) {
<a name="l00230"></a>00230     <span class="keywordtype">int</span> di = tree-&gt;dataIndex [i] .index ;
<a name="l00231"></a>00231     <span class="keywordtype">float</span> datum = forest-&gt;<a class="code" href="struct__VlKDForest.html#d30a7279096b730eeb88c39da3008c22">data</a> [di * forest-&gt;<a class="code" href="struct__VlKDForest.html#db5257b5aaa1b5a3b28f75ce86604067">numDimensions</a> + splitDimension-&gt;dimension] ;
<a name="l00232"></a>00232     tree-&gt;dataIndex [i] .value = datum ;
<a name="l00233"></a>00233   }
<a name="l00234"></a>00234   qsort (tree-&gt;dataIndex + dataBegin,
<a name="l00235"></a>00235          dataEnd - dataBegin,
<a name="l00236"></a>00236          sizeof (VlKDTreeDataIndexEntry),
<a name="l00237"></a>00237          <a class="code" href="kdtree_8c.html#9de65262a119712c22e68fbfca3d02ac" title="Compare KDTree index entries for sorting.">vl_kdtree_compare_index_entries</a>) ;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <span class="comment">/* determine split threshold */</span>
<a name="l00240"></a>00240   <span class="keywordflow">switch</span> (forest-&gt;<a class="code" href="struct__VlKDForest.html#481cb9a02a79f0dd1bfb4308e6055ce5">thresholdingMethod</a>) {
<a name="l00241"></a>00241     <span class="keywordflow">case</span> VL_KDTREE_MEAN :
<a name="l00242"></a>00242       node-&gt;splitThreshold = splitDimension-&gt;mean ;
<a name="l00243"></a>00243       <span class="keywordflow">for</span> (splitIndex = dataBegin ;
<a name="l00244"></a>00244            splitIndex &lt; dataEnd &amp;&amp; tree-&gt;dataIndex[splitIndex].value &lt;= node-&gt;splitThreshold ;
<a name="l00245"></a>00245            ++ splitIndex) ;
<a name="l00246"></a>00246       splitIndex -= 1 ;
<a name="l00247"></a>00247       <span class="comment">/* If the mean does not provide a proper partition, fall back to</span>
<a name="l00248"></a>00248 <span class="comment">       * median. This usually happens if all points have the same</span>
<a name="l00249"></a>00249 <span class="comment">       * value and the zero variance test fails for numerical accuracy</span>
<a name="l00250"></a>00250 <span class="comment">       * reasons. In this case, also due to numerical accuracy, the</span>
<a name="l00251"></a>00251 <span class="comment">       * mean value can be smaller, equal, or larger than all</span>
<a name="l00252"></a>00252 <span class="comment">       * points. */</span>
<a name="l00253"></a>00253       <span class="keywordflow">if</span> (dataBegin &lt;= splitIndex &amp;&amp; splitIndex + 1 &lt; dataEnd) break ;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255     <span class="keywordflow">case</span> VL_KDTREE_MEDIAN :
<a name="l00256"></a>00256       medianIndex = (dataBegin + dataEnd - 1) / 2 ;
<a name="l00257"></a>00257       splitIndex = medianIndex ;
<a name="l00258"></a>00258       node -&gt; splitThreshold = tree-&gt;dataIndex[medianIndex].value ;
<a name="l00259"></a>00259       break ;
<a name="l00260"></a>00260 
<a name="l00261"></a>00261     <span class="keywordflow">default</span>:
<a name="l00262"></a>00262       assert(0) ;
<a name="l00263"></a>00263   }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">/* divide subparts */</span>
<a name="l00266"></a>00266   node-&gt;lowerChild = <a class="code" href="kdtree_8c.html#0f8bcfc1860957b70cdbcbf6e03e0425" title="Allocate a new node from the tree pool.">vl_kdtree_node_new</a> (tree, nodeIndex) ;
<a name="l00267"></a>00267   <a class="code" href="kdtree_8c.html#e7b96fbb8190854a8fef25e7e4d82bc0" title="Build KDTree recursively.">vl_kdtree_build_recursively</a> (forest, tree, node-&gt;lowerChild, dataBegin, splitIndex + 1, depth + 1) ;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   node-&gt;upperChild = <a class="code" href="kdtree_8c.html#0f8bcfc1860957b70cdbcbf6e03e0425" title="Allocate a new node from the tree pool.">vl_kdtree_node_new</a> (tree, nodeIndex) ;
<a name="l00270"></a>00270   <a class="code" href="kdtree_8c.html#e7b96fbb8190854a8fef25e7e4d82bc0" title="Build KDTree recursively.">vl_kdtree_build_recursively</a> (forest, tree, node-&gt;upperChild, splitIndex + 1, dataEnd, depth + 1) ;
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00280"></a>00280 VL_EXPORT
<a name="l00281"></a>00281 <a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> *
<a name="l00282"></a><a class="code" href="kdtree_8h.html#0a94ee1ef061e4c51305bc0a3cf948af">00282</a> <a class="code" href="kdtree_8c.html#0a94ee1ef061e4c51305bc0a3cf948af" title="Create new KDForest object.">vl_kdforest_new</a> (<span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> numDimensions, <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> numTrees)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284   <a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> * <span class="keyword">self</span> = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a>)) ;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="keyword">self</span> -&gt; numData = 0 ;
<a name="l00287"></a>00287   <span class="keyword">self</span> -&gt; data = 0 ;
<a name="l00288"></a>00288   <span class="keyword">self</span> -&gt; numDimensions = numDimensions ;
<a name="l00289"></a>00289   <span class="keyword">self</span> -&gt; numTrees = numTrees ;
<a name="l00290"></a>00290   <span class="keyword">self</span> -&gt; trees = 0 ;
<a name="l00291"></a>00291   <span class="keyword">self</span> -&gt; thresholdingMethod = VL_KDTREE_MEDIAN ;
<a name="l00292"></a>00292   <span class="keyword">self</span> -&gt; splitHeapSize = (numTrees == 1) ? 1 : VL_KDTREE_SPLIT_HEALP_SIZE ;
<a name="l00293"></a>00293   <span class="keyword">self</span> -&gt; splitHeapNumNodes = 0 ;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   <span class="keyword">self</span> -&gt; searchHeapArray = 0 ;
<a name="l00296"></a>00296   <span class="keyword">self</span> -&gt; searchHeapNumNodes = 0 ;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="keyword">self</span> -&gt; searchMaxNumComparisons = 0 ;
<a name="l00300"></a>00300   <span class="keyword">self</span> -&gt; searchIdBook = 0 ;
<a name="l00301"></a>00301   <span class="keyword">self</span> -&gt; searchId = 0 ;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="keywordflow">return</span> self ;
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00312"></a>00312 VL_EXPORT <span class="keywordtype">void</span>
<a name="l00313"></a><a class="code" href="kdtree_8h.html#f2e093f010ccc6db5e8d19f6a7b31684">00313</a> <a class="code" href="kdtree_8c.html#f2e093f010ccc6db5e8d19f6a7b31684" title="Delete KDForest object.">vl_kdforest_delete</a> (<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> * <span class="keyword">self</span>)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315   <span class="keywordtype">int</span> ti ;
<a name="l00316"></a>00316   <span class="keywordflow">if</span> (self-&gt;searchIdBook) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (self-&gt;searchIdBook) ;
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (self-&gt;trees) {
<a name="l00318"></a>00318     <span class="keywordflow">for</span> (ti = 0 ; ti &lt; <span class="keyword">self</span>-&gt;numTrees ; ++ ti) {
<a name="l00319"></a>00319       <span class="keywordflow">if</span> (self-&gt;trees[ti]) {
<a name="l00320"></a>00320         <span class="keywordflow">if</span> (self-&gt;trees[ti]-&gt;nodes) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (self-&gt;trees[ti]-&gt;nodes) ;
<a name="l00321"></a>00321         <span class="keywordflow">if</span> (self-&gt;trees[ti]-&gt;dataIndex) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (self-&gt;trees[ti]-&gt;dataIndex) ;
<a name="l00322"></a>00322       }
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324     <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (self-&gt;trees) ;
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326   <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (<span class="keyword">self</span>) ;
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 
<a name="l00341"></a>00341 VL_EXPORT <span class="keywordtype">void</span>
<a name="l00342"></a><a class="code" href="kdtree_8h.html#eaa0ff64d65550d41615464efd4098d8">00342</a> <a class="code" href="kdtree_8c.html#eaa0ff64d65550d41615464efd4098d8" title="Build KDTree from data.">vl_kdforest_build</a> (<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> * <span class="keyword">self</span>, <span class="keywordtype">int</span> numData, <span class="keywordtype">float</span> <span class="keyword">const</span> * data)
<a name="l00343"></a>00343 {
<a name="l00344"></a>00344   <span class="keywordtype">int</span> di, ti ;
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="comment">/* need to check: if alredy built, clean first */</span>
<a name="l00347"></a>00347   <span class="keyword">self</span>-&gt;data = data ;
<a name="l00348"></a>00348   <span class="keyword">self</span>-&gt;numData = numData ;
<a name="l00349"></a>00349   <span class="keyword">self</span>-&gt;trees = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(VlKDTree*) * self-&gt;numTrees) ;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="keywordflow">for</span> (ti = 0 ; ti &lt; <span class="keyword">self</span>-&gt;numTrees ; ++ ti) {
<a name="l00352"></a>00352     <span class="keyword">self</span>-&gt;trees[ti] = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(VlKDTree)) ;
<a name="l00353"></a>00353     <span class="keyword">self</span>-&gt;trees[ti]-&gt;dataIndex = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(VlKDTreeDataIndexEntry) * self-&gt;numData) ;
<a name="l00354"></a>00354     <span class="keywordflow">for</span> (di = 0 ; di &lt; <span class="keyword">self</span>-&gt;numData ; ++ di) {
<a name="l00355"></a>00355       <span class="keyword">self</span>-&gt;trees[ti]-&gt;dataIndex[di].index = di ;
<a name="l00356"></a>00356     }
<a name="l00357"></a>00357     <span class="keyword">self</span>-&gt;trees[ti]-&gt;numUsedNodes = 0 ;
<a name="l00358"></a>00358     <span class="comment">/* num. nodes of a complete binary tree with numData leaves */</span>
<a name="l00359"></a>00359     <span class="keyword">self</span>-&gt;trees[ti]-&gt;numAllocatedNodes = 2 * <span class="keyword">self</span>-&gt;numData - 1 ;
<a name="l00360"></a>00360     <span class="keyword">self</span>-&gt;trees[ti]-&gt;nodes = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(VlKDTreeNode) * self-&gt;trees[ti]-&gt;numAllocatedNodes) ;
<a name="l00361"></a>00361     <span class="keyword">self</span>-&gt;trees[ti]-&gt;depth = 0 ;
<a name="l00362"></a>00362     <a class="code" href="kdtree_8c.html#e7b96fbb8190854a8fef25e7e4d82bc0" title="Build KDTree recursively.">vl_kdtree_build_recursively</a> (<span class="keyword">self</span>, self-&gt;trees[ti],
<a name="l00363"></a>00363                                  <a class="code" href="kdtree_8c.html#0f8bcfc1860957b70cdbcbf6e03e0425" title="Allocate a new node from the tree pool.">vl_kdtree_node_new</a>(self-&gt;trees[ti], 0), 0,
<a name="l00364"></a>00364                                  self-&gt;numData, 0) ;
<a name="l00365"></a>00365   }
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 
<a name="l00372"></a>00372 VL_INLINE
<a name="l00373"></a><a class="code" href="kdtree_8c.html#d3efeee6f8198f0c3bd345afebe9b894">00373</a> <span class="keywordtype">float</span> <a class="code" href="kdtree_8c.html#d3efeee6f8198f0c3bd345afebe9b894">calc_dist2</a> (<span class="keywordtype">float</span> <span class="keyword">const</span> * a, <span class="keywordtype">float</span> <span class="keyword">const</span> * b, <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> N)
<a name="l00374"></a>00374 {
<a name="l00375"></a>00375   <span class="keywordtype">float</span> acc = 0 ;
<a name="l00376"></a>00376   <span class="keywordtype">float</span> d0, d1, d2, d3 ;
<a name="l00377"></a>00377   <span class="keywordtype">float</span> <span class="keyword">const</span> * age = a + N - 3 ;
<a name="l00378"></a>00378   <span class="keywordtype">float</span> <span class="keyword">const</span> * ae = a + N ;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="keywordflow">while</span> (a &lt; age) {
<a name="l00381"></a>00381     d0 = *a++ - *b++ ;
<a name="l00382"></a>00382     d1 = *a++ - *b++ ;
<a name="l00383"></a>00383     d2 = *a++ - *b++ ;
<a name="l00384"></a>00384     d3 = *a++ - *b++ ;
<a name="l00385"></a>00385     acc += d0 * d0 ;
<a name="l00386"></a>00386     acc += d1 * d1 ;
<a name="l00387"></a>00387     acc += d2 * d2 ;
<a name="l00388"></a>00388     acc += d3 * d3 ;
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390   <span class="keywordflow">while</span> (a &lt; ae) {
<a name="l00391"></a>00391     d0 = *a++ - *b++ ;
<a name="l00392"></a>00392     acc += d0 * d0 ;
<a name="l00393"></a>00393   }
<a name="l00394"></a>00394   <span class="keywordflow">return</span> acc ;
<a name="l00395"></a>00395 }
<a name="l00396"></a>00396 
<a name="l00401"></a>00401 VL_EXPORT <span class="keywordtype">int</span>
<a name="l00402"></a><a class="code" href="kdtree_8c.html#cff94747d3068233115a58655f2e3f5c">00402</a> <a class="code" href="kdtree_8c.html#cff94747d3068233115a58655f2e3f5c">vl_kdforest_query_recursively</a> (<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a>  * <span class="keyword">self</span>,
<a name="l00403"></a>00403                                VlKDTree * tree,
<a name="l00404"></a>00404                                <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> nodeIndex,
<a name="l00405"></a>00405                                <a class="code" href="struct__VlKDForestNeighbor.html" title="Neighbor of a query point.">VlKDForestNeighbor</a> * neighbors,
<a name="l00406"></a>00406                                <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> numNeighbors,
<a name="l00407"></a>00407                                <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> * numAddedNeighbors,
<a name="l00408"></a>00408                                <span class="keywordtype">float</span> dist,
<a name="l00409"></a>00409                                <span class="keywordtype">float</span> <span class="keyword">const</span> * query)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411   VlKDTreeNode <span class="keyword">const</span> * node = tree-&gt;nodes + nodeIndex ;
<a name="l00412"></a>00412   <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> i = node-&gt;splitDimension ;
<a name="l00413"></a>00413   <span class="keywordtype">int</span> nextChild, saveChild ;
<a name="l00414"></a>00414   <span class="keywordtype">float</span> delta, saveDist ;
<a name="l00415"></a>00415   <span class="keywordtype">float</span> x = query [i] ;
<a name="l00416"></a>00416   <span class="keywordtype">float</span> x1 = node-&gt;lowerBound ;
<a name="l00417"></a>00417   <span class="keywordtype">float</span> x2 = node-&gt;splitThreshold ;
<a name="l00418"></a>00418   <span class="keywordtype">float</span> x3 = node-&gt;upperBound ;
<a name="l00419"></a>00419   VlKDForestSearchState * searchState ;
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="keyword">self</span>-&gt;searchNumRecursions ++ ;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   <span class="comment">/* base case: this is a leaf node */</span>
<a name="l00424"></a>00424   <span class="keywordflow">if</span> (node-&gt;lowerChild &lt; 0) {
<a name="l00425"></a>00425     <span class="keywordtype">int</span> begin = - node-&gt;lowerChild - 1 ;
<a name="l00426"></a>00426     <span class="keywordtype">int</span> end   = - node-&gt;upperChild - 1 ;
<a name="l00427"></a>00427     <span class="keywordtype">int</span> iter ;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="keywordflow">for</span> (iter = begin ;
<a name="l00430"></a>00430          iter &lt; end &amp;&amp;
<a name="l00431"></a>00431          (<span class="keyword">self</span>-&gt;searchMaxNumComparisons == 0 ||
<a name="l00432"></a>00432           <span class="keyword">self</span>-&gt;searchNumComparisons &lt; <span class="keyword">self</span>-&gt;searchMaxNumComparisons) ;
<a name="l00433"></a>00433          ++ iter) {
<a name="l00434"></a>00434 
<a name="l00435"></a>00435       <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> di = tree-&gt;dataIndex [iter].index ;
<a name="l00436"></a>00436       <span class="keywordtype">float</span> <span class="keyword">const</span> * datum = <span class="keyword">self</span>-&gt;data + di * <span class="keyword">self</span>-&gt;numDimensions ;
<a name="l00437"></a>00437 
<a name="l00438"></a>00438       <span class="comment">/* multiple KDTrees share the database points and we must avoid</span>
<a name="l00439"></a>00439 <span class="comment">       * adding the same point twice */</span>
<a name="l00440"></a>00440       <span class="keywordflow">if</span> (self-&gt;searchIdBook [di] == self-&gt;searchId) continue ;
<a name="l00441"></a>00441       <span class="keyword">self</span>-&gt;searchIdBook [di] = <span class="keyword">self</span>-&gt;searchId ;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443       <span class="comment">/* compare the query to this point */</span>
<a name="l00444"></a>00444       dist = <a class="code" href="kdtree_8c.html#d3efeee6f8198f0c3bd345afebe9b894">calc_dist2</a> (query, datum, self-&gt;numDimensions) ;
<a name="l00445"></a>00445       <span class="keyword">self</span>-&gt;searchNumComparisons += 1 ;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447       <span class="comment">/* see if it should be added to the result set */</span>
<a name="l00448"></a>00448       <span class="keywordflow">if</span> (*numAddedNeighbors &lt; numNeighbors) {
<a name="l00449"></a>00449         <a class="code" href="struct__VlKDForestNeighbor.html" title="Neighbor of a query point.">VlKDForestNeighbor</a> * newNeighbor = neighbors + *numAddedNeighbors ;
<a name="l00450"></a>00450         newNeighbor-&gt;<a class="code" href="struct__VlKDForestNeighbor.html#d77011fd794be4378b281877102407fb">index</a> = di ;
<a name="l00451"></a>00451         newNeighbor-&gt;<a class="code" href="struct__VlKDForestNeighbor.html#3ab9a0a6d3e6340980c5fdd70356fe88">distance</a> = dist ;
<a name="l00452"></a>00452         vl_kdforest_neighbor_heap_push (neighbors, numAddedNeighbors) ;
<a name="l00453"></a>00453       } <span class="keywordflow">else</span> {
<a name="l00454"></a>00454         <a class="code" href="struct__VlKDForestNeighbor.html" title="Neighbor of a query point.">VlKDForestNeighbor</a> * largestNeighbor = neighbors + 0 ;
<a name="l00455"></a>00455         <span class="keywordflow">if</span> (largestNeighbor-&gt;<a class="code" href="struct__VlKDForestNeighbor.html#3ab9a0a6d3e6340980c5fdd70356fe88">distance</a> &gt; dist) {
<a name="l00456"></a>00456           largestNeighbor-&gt;<a class="code" href="struct__VlKDForestNeighbor.html#d77011fd794be4378b281877102407fb">index</a> = di ;
<a name="l00457"></a>00457           largestNeighbor-&gt;<a class="code" href="struct__VlKDForestNeighbor.html#3ab9a0a6d3e6340980c5fdd70356fe88">distance</a> = dist ;
<a name="l00458"></a>00458           vl_kdforest_neighbor_heap_update (neighbors, *numAddedNeighbors, 0) ;
<a name="l00459"></a>00459         }
<a name="l00460"></a>00460       }
<a name="l00461"></a>00461     } <span class="comment">/* next data point */</span>
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="keywordflow">return</span> nodeIndex ;
<a name="l00464"></a>00464   }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="preprocessor">#if 0</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span>  assert (x1 &lt;= x2 &amp;&amp; x2 &lt;= x3) ;
<a name="l00468"></a>00468   assert (node-&gt;lowerChild &gt;= 0) ;
<a name="l00469"></a>00469   assert (node-&gt;upperChild &gt;= 0) ;
<a name="l00470"></a>00470 <span class="preprocessor">#endif</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span>
<a name="l00472"></a>00472   <span class="comment">/*</span>
<a name="l00473"></a>00473 <span class="comment">   *   x1  x2 x3</span>
<a name="l00474"></a>00474 <span class="comment">   * x (---|---]</span>
<a name="l00475"></a>00475 <span class="comment">   *   (--x|---]</span>
<a name="l00476"></a>00476 <span class="comment">   *   (---|x--]</span>
<a name="l00477"></a>00477 <span class="comment">   *   (---|---] x</span>
<a name="l00478"></a>00478 <span class="comment">   */</span>
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   delta = x - x2 ;
<a name="l00481"></a>00481   saveDist = dist + delta*delta ;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="keywordflow">if</span> (x &lt;= x2) {
<a name="l00484"></a>00484     nextChild = node-&gt;lowerChild ;
<a name="l00485"></a>00485     saveChild = node-&gt;upperChild ;
<a name="l00486"></a>00486     <span class="keywordflow">if</span> (x &lt;= x1) {
<a name="l00487"></a>00487       delta = x - x1 ;
<a name="l00488"></a>00488       saveDist -= delta*delta ;
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490   } <span class="keywordflow">else</span> {
<a name="l00491"></a>00491     nextChild = node-&gt;upperChild ;
<a name="l00492"></a>00492     saveChild = node-&gt;lowerChild ;
<a name="l00493"></a>00493     <span class="keywordflow">if</span> (x &gt; x3) {
<a name="l00494"></a>00494       delta = x - x3 ;
<a name="l00495"></a>00495       saveDist -= delta*delta ;
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497   }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499   <span class="keywordflow">if</span> (*numAddedNeighbors &lt; numNeighbors || neighbors[0].distance &gt; saveDist) {
<a name="l00500"></a>00500     searchState = <span class="keyword">self</span>-&gt;searchHeapArray + <span class="keyword">self</span>-&gt;searchHeapNumNodes ;
<a name="l00501"></a>00501     searchState-&gt;tree = tree ;
<a name="l00502"></a>00502     searchState-&gt;nodeIndex = saveChild ;
<a name="l00503"></a>00503     searchState-&gt;distanceLowerBound = saveDist ;
<a name="l00504"></a>00504     vl_kdforest_search_heap_push (self-&gt;searchHeapArray,
<a name="l00505"></a>00505                                   &amp;self-&gt;searchHeapNumNodes) ;
<a name="l00506"></a>00506   }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508   <span class="keywordflow">return</span> <a class="code" href="kdtree_8c.html#cff94747d3068233115a58655f2e3f5c">vl_kdforest_query_recursively</a> (<span class="keyword">self</span>,
<a name="l00509"></a>00509                                         tree,
<a name="l00510"></a>00510                                         nextChild,
<a name="l00511"></a>00511                                         neighbors,
<a name="l00512"></a>00512                                         numNeighbors,
<a name="l00513"></a>00513                                         numAddedNeighbors,
<a name="l00514"></a>00514                                         dist,
<a name="l00515"></a>00515                                         query) ;
<a name="l00516"></a>00516 }
<a name="l00517"></a>00517 
<a name="l00525"></a>00525 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00526"></a><a class="code" href="kdtree_8c.html#b35f55ad5a3dc909a5d7a4f0795dc7a4">00526</a> <a class="code" href="kdtree_8c.html#b35f55ad5a3dc909a5d7a4f0795dc7a4" title="Compute tree bounds recursively.">vl_kdtree_calc_bounds_recursively</a> (VlKDTree * tree,
<a name="l00527"></a>00527                                    <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> nodeIndex, <span class="keywordtype">float</span> * searchBounds)
<a name="l00528"></a>00528 {
<a name="l00529"></a>00529   VlKDTreeNode * node = tree-&gt;nodes + nodeIndex ;
<a name="l00530"></a>00530   <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> i = node-&gt;splitDimension ;
<a name="l00531"></a>00531   <span class="keywordtype">float</span> t = node-&gt;splitThreshold ;
<a name="l00532"></a>00532 
<a name="l00533"></a>00533   node-&gt;lowerBound = searchBounds [2 * i + 0] ;
<a name="l00534"></a>00534   node-&gt;upperBound = searchBounds [2 * i + 1] ;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536   <span class="keywordflow">if</span> (node-&gt;lowerChild &gt; 0) {
<a name="l00537"></a>00537     searchBounds [2 * i + 1] = t ;
<a name="l00538"></a>00538     <a class="code" href="kdtree_8c.html#b35f55ad5a3dc909a5d7a4f0795dc7a4" title="Compute tree bounds recursively.">vl_kdtree_calc_bounds_recursively</a> (tree, node-&gt;lowerChild, searchBounds) ;
<a name="l00539"></a>00539     searchBounds [2 * i + 1] = node-&gt;upperBound ;
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541   <span class="keywordflow">if</span> (node-&gt;upperChild &gt; 0) {
<a name="l00542"></a>00542     searchBounds [2 * i + 0] = t ;
<a name="l00543"></a>00543     <a class="code" href="kdtree_8c.html#b35f55ad5a3dc909a5d7a4f0795dc7a4" title="Compute tree bounds recursively.">vl_kdtree_calc_bounds_recursively</a> (tree, node-&gt;upperChild, searchBounds) ;
<a name="l00544"></a>00544     searchBounds [2 * i + 0] = node-&gt;lowerBound ;
<a name="l00545"></a>00545   }
<a name="l00546"></a>00546 }
<a name="l00547"></a>00547 
<a name="l00562"></a>00562 VL_EXPORT <span class="keywordtype">int</span>
<a name="l00563"></a><a class="code" href="kdtree_8h.html#977a93b67b3358bb20c5f5c169350184">00563</a> <a class="code" href="kdtree_8c.html#977a93b67b3358bb20c5f5c169350184" title="Query operation.">vl_kdforest_query</a> (<a class="code" href="struct__VlKDForest.html" title="KDForest object.">VlKDForest</a> * <span class="keyword">self</span>,
<a name="l00564"></a>00564                    <a class="code" href="struct__VlKDForestNeighbor.html" title="Neighbor of a query point.">VlKDForestNeighbor</a> * neighbors,
<a name="l00565"></a>00565                    <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> numNeighbors,
<a name="l00566"></a>00566                    <span class="keywordtype">float</span> <span class="keyword">const</span> * query)
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568   <span class="keywordtype">int</span> i, ti ;
<a name="l00569"></a>00569   <a class="code" href="host_8h.html#d32e7f8ec7333ff33998cf671a3b1412" title="Boolean.">vl_bool</a> exactSearch = (<span class="keyword">self</span>-&gt;searchMaxNumComparisons == 0) ;
<a name="l00570"></a>00570   VlKDForestSearchState * searchState  ;
<a name="l00571"></a>00571   <span class="keywordtype">int</span> <span class="keywordtype">unsigned</span> numAddedNeighbors = 0 ;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   assert (neighbors) ;
<a name="l00574"></a>00574   assert (numNeighbors &gt; 0) ;
<a name="l00575"></a>00575   assert (query) ;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577   <span class="comment">/* this number is used to differentiate a query from the next */</span>
<a name="l00578"></a>00578   <span class="keyword">self</span> -&gt; searchId += 1 ;
<a name="l00579"></a>00579   <span class="keyword">self</span> -&gt; searchNumRecursions = 0 ;
<a name="l00580"></a>00580 
<a name="l00581"></a>00581   <span class="keywordflow">if</span> (! <span class="keyword">self</span> -&gt; searchHeapArray) {
<a name="l00582"></a>00582     <span class="comment">/* count number of tree nodes */</span>
<a name="l00583"></a>00583     <span class="comment">/* add support structures */</span>
<a name="l00584"></a>00584     <span class="keywordtype">int</span> maxNumNodes = 0 ;
<a name="l00585"></a>00585     <span class="keywordflow">for</span> (ti = 0 ; ti &lt; <span class="keyword">self</span>-&gt;numTrees ; ++ti) {
<a name="l00586"></a>00586       maxNumNodes += <span class="keyword">self</span>-&gt;trees[ti]-&gt;numUsedNodes ;
<a name="l00587"></a>00587     }
<a name="l00588"></a>00588     <span class="keyword">self</span> -&gt; searchHeapArray = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(VlKDForestSearchState) * maxNumNodes) ;
<a name="l00589"></a>00589     <span class="keyword">self</span> -&gt; searchIdBook = <a class="code" href="generic_8h.html#93ff990a07af5b4b69bbde7c8e021e28" title="Call customizable calloc function.">vl_calloc</a> (<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>), self-&gt;numData) ;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591     <span class="keywordflow">for</span> (ti = 0 ; ti &lt; <span class="keyword">self</span>-&gt;numTrees ; ++ti) {
<a name="l00592"></a>00592       <span class="keywordtype">float</span> * searchBounds = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a>(<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 2 * self-&gt;numDimensions) ;
<a name="l00593"></a>00593       <span class="keywordtype">float</span> * iter = searchBounds  ;
<a name="l00594"></a>00594       <span class="keywordtype">float</span> * end = iter + 2 * <span class="keyword">self</span>-&gt;numDimensions ;
<a name="l00595"></a>00595       <span class="keywordflow">while</span> (iter &lt; end) {
<a name="l00596"></a>00596         *iter++ = - <a class="code" href="mathop_8h.html#7c8e51b4132fa5072a31ec38770e22c6" title="IEEE single precision positive infinity (not signaling).">VL_INFINITY_F</a> ;
<a name="l00597"></a>00597         *iter++ = + <a class="code" href="mathop_8h.html#7c8e51b4132fa5072a31ec38770e22c6" title="IEEE single precision positive infinity (not signaling).">VL_INFINITY_F</a> ;
<a name="l00598"></a>00598       }
<a name="l00599"></a>00599       <a class="code" href="kdtree_8c.html#b35f55ad5a3dc909a5d7a4f0795dc7a4" title="Compute tree bounds recursively.">vl_kdtree_calc_bounds_recursively</a> (self-&gt;trees[ti], 0, searchBounds) ;
<a name="l00600"></a>00600       <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (searchBounds) ;
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602   }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="keyword">self</span>-&gt;searchNumComparisons = 0 ;
<a name="l00605"></a>00605   <span class="keyword">self</span>-&gt;searchNumSimplifications = 0 ;
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="comment">/* put the root node into the search heap */</span>
<a name="l00608"></a>00608   <span class="keyword">self</span>-&gt;searchHeapNumNodes = 0 ;
<a name="l00609"></a>00609   <span class="keywordflow">for</span> (ti = 0 ; ti &lt; <span class="keyword">self</span>-&gt;numTrees ; ++ ti) {
<a name="l00610"></a>00610     searchState = <span class="keyword">self</span>-&gt;searchHeapArray + <span class="keyword">self</span>-&gt;searchHeapNumNodes ;
<a name="l00611"></a>00611     searchState -&gt; tree = <span class="keyword">self</span>-&gt;trees[ti] ;
<a name="l00612"></a>00612     searchState -&gt; nodeIndex = 0 ;
<a name="l00613"></a>00613     searchState -&gt; distanceLowerBound = 0 ;
<a name="l00614"></a>00614     vl_kdforest_search_heap_push (self-&gt;searchHeapArray, &amp;self-&gt;searchHeapNumNodes) ;
<a name="l00615"></a>00615   }
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="comment">/* branch and bound */</span>
<a name="l00618"></a>00618   <span class="keywordflow">while</span> (exactSearch || self-&gt;searchNumComparisons &lt; self-&gt;searchMaxNumComparisons)
<a name="l00619"></a>00619   {
<a name="l00620"></a>00620     <span class="comment">/* pop the next optimal search node */</span>
<a name="l00621"></a>00621     VlKDForestSearchState * searchState = vl_kdforest_search_heap_pop
<a name="l00622"></a>00622       (self-&gt;searchHeapArray, &amp;self-&gt;searchHeapNumNodes) ;
<a name="l00623"></a>00623 
<a name="l00624"></a>00624     <span class="comment">/* break if search space completed */</span>
<a name="l00625"></a>00625     <span class="keywordflow">if</span> (searchState == NULL) {
<a name="l00626"></a>00626       break ;
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629     <span class="comment">/* break if no better solution may exist */</span>
<a name="l00630"></a>00630     <span class="keywordflow">if</span> (numAddedNeighbors == numNeighbors &amp;&amp;
<a name="l00631"></a>00631         neighbors[0].distance &lt; searchState-&gt;distanceLowerBound) {
<a name="l00632"></a>00632       <span class="keyword">self</span>-&gt;searchNumSimplifications ++ ;
<a name="l00633"></a>00633       break ;
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 
<a name="l00636"></a>00636     <a class="code" href="kdtree_8c.html#cff94747d3068233115a58655f2e3f5c">vl_kdforest_query_recursively</a> (<span class="keyword">self</span>,
<a name="l00637"></a>00637                                    searchState-&gt;tree,
<a name="l00638"></a>00638                                    searchState-&gt;nodeIndex,
<a name="l00639"></a>00639                                    neighbors,
<a name="l00640"></a>00640                                    numNeighbors,
<a name="l00641"></a>00641                                    &amp;numAddedNeighbors,
<a name="l00642"></a>00642                                    searchState-&gt;distanceLowerBound,
<a name="l00643"></a>00643                                    query) ;
<a name="l00644"></a>00644   }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="comment">/* sort neighbors by increasing distance */</span>
<a name="l00647"></a>00647   <span class="keywordflow">for</span> (i = numAddedNeighbors ;  i &lt; numNeighbors ; ++ i) {
<a name="l00648"></a>00648     neighbors[i].<a class="code" href="struct__VlKDForestNeighbor.html#d77011fd794be4378b281877102407fb">index</a> = -1 ;
<a name="l00649"></a>00649     neighbors[i].<a class="code" href="struct__VlKDForestNeighbor.html#3ab9a0a6d3e6340980c5fdd70356fe88">distance</a> = <a class="code" href="mathop_8h.html#fcbfd66dfa72bf495e08e1d622d6da0e" title="IEEE single precision NaN (not signaling).">VL_NAN_F</a> ;
<a name="l00650"></a>00650   }
<a name="l00651"></a>00651   <span class="keywordflow">while</span> (numAddedNeighbors) {
<a name="l00652"></a>00652     vl_kdforest_neighbor_heap_pop (neighbors, &amp;numAddedNeighbors) ;
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="keywordflow">return</span> <span class="keyword">self</span>-&gt;searchNumComparisons ;
<a name="l00656"></a>00656 }
</pre></div></div>
     <!-- Doc Here -->
    </div>
   
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-09 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->
  
  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
